#+TITLE: TELLEP
#+AUTHOR: Wouter Beek
#+STARTUP: latexpreview

A simplistic Description Logic reasoner.

* TR;DR

Start TELLEP in debug mode, for fancy printed messages:

#+BEGIN_SRC sh
$ swipl debug.pl
#+END_SRC

First, create your T-Box by asserting inclusion axioms:

#+BEGIN_SRC prolog
?- human subclass mortal.
#+END_SRC

Then, assert your A-Box:

#+BEGIN_SRC prolog
?- socrates :: human.
#+END_SRC

Whenever something can de deduced, the reasoner will immediately
answer:

#+BEGIN_SRC
socrates::human
human ⊑ mortal
────────────────
socrates::mortal
#+END_SRC

* Interaction language

For interacting with the reasoner we use an ASCII-based notation that
is easy to type on most keyboards.  We stay close to the /Manchester
Syntax/:

  | *Manchester formula* | *DL formula* |
  |----------------------+--------------|
  | subClassOf(C,D)      | C ⊑ D        |
  | fail                 | ⊥            |
  | not A                | (¬A)         |
  | C and D              | (C ⊓ D)      |
  | R only C             | ∀R C         |
  | R some C             | ∃R C         |
  | a::C                 | a::C         |
  | (a,b)::R             | (a,b)::R     |

* Presentation language

For presenting/printing results we can use non-ASCII symbols.  We try
to stay close to the syntax used in /Description Logic Handbook/:

  | *Formula* | *Fancy name*                       | *Meaning*                                                                                                  |
  |-----------+------------------------------------+------------------------------------------------------------------------------------------------------------|
  | C ⊑ D     | inclusion axiom                    | $C^\mathcal{I} \subseteq D^\mathcal{I}$                                                                    |
  | ⊥         | falsum                             | $\emptyset$                                                                                                |
  | (¬A)      | atomic negation                    | $\Delta^\mathcal{I} \setminus A^\mathcal{I}$                                                               |
  | (C ⊓ D)   | intersection                       | $C^\mathcal{I} \cap D^\mathcal{I}$                                                                         |
  | ∀R C      | value restriction                  | $\{ a \in \Delta^\mathcal{I} \vert \forall b . (a,b) \in R^\mathcal{I} \rightarrow b \in C^\mathcal{I} \}$ |
  | ∃R C      | limited existential quantification | $\{ a \in \Delta^\mathcal{I} \vert \exists b . (a,b) \in R^\mathcal{I}}$                                   |
  | a::C      | concept assertion                  | $a^\mathcal{I} \in C^\mathcal{I}$                                                                          |
  | (a,b)::R  | role assertion                     | $(a^\mathcal{I}, b^\mathcal{I}) \in R^\mathcal{I}$                                                         |

* Applications

** Consistency checking
synonym: <<Satisfiability>>

When the state becomes inconsistent the falsum is derived.

** Query answering
Is socrates mortal?

#+BEGIN_SRC prolog
?- socrates :: mortal.
#+END_SRC

** Instance checking
Is individual ‘a’ an instance of ‘C’?

#+BEGIN_SRC prolog
?- a :: C.
#+END_SRC

** subsumption
Are all C's also D's?

#+BEGIN_SRC prolog
?- C ⊑ D.
#+END_SRC
